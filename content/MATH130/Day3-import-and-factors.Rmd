---
title: 'Day 3 - Data import, functions and factors'
author: ''
date: '2017-08-29'
slug: day-3-import
categories: []
tags: []
draft: TRUE
---

# Preparation and Introduction

### Student Learning Objectives
After completing this lab you should be able to

* Import data that is stored in an external Excel, CSV or tab-delimited text file into R.
* Specify arguments to functions in R positionally and by name. 
* Create and control the labeling and ordering of categorical variables (factors).

### Preparation: What's a delimiter? 
Before we go much further, let's talk about the word **_delimiter_**. This is the character, or symbol, that separates columns of data from each other when stored in an external file. This file could be a simple `.txt` text file or an `.xlsx` Excel file. Recall back to the Data Camp exercises on data frames and matrices. Each column in the matrix represented data on a specific variable. Something had to tell R how to distinguish which values went with which variable. 

There are two main types of delimiters we will consider in this class; comma and tab. That does not mean that data can't be stored in other ways, these are just the two most common. 


### Preparation: Data to download
* Go to the cleaned data section of the [datasets page](../../data/) and download the following data sets: `NCBirths`, `email`, and `parHIV`. 
* **DO NOT RENAME ANYTHING** If you download multiple copies of the data, do not keep the versions that have a (1) or some number in the name. 
* Put all downloaded data files into your MATH130 folder. 

In all the examples below, the path shown (`../data/`) is the path on **MY** computer.You will have to update this path to **YOUR** path on **YOUR** machine that points to your MATH130 folder. 


# Importing Data

In this workshop we are only going to explore reading flat files that exist on your computer into R from three most commonly used data sources: A tab-delimited text file, A CSV file and an Excel file. Ideally each row represents data on a single observation and each column contains data on a single variable, or characteristic, of the observation. This is called `tidy data`. We will start to learn some tools to look at the data, and for getting data from an external file into R for analysis. 


### Text files
Text files are very simple files that have a `.txt` file extension. Common delimiters include a space, a comma (,) or a tab. Uncommon delimiters could include a % or even a semi-colon. Follow along with these examples and make sure you can read in the data correctly and that it matches what is shown below. 

We will use the `read.table()` function that is in base R to read in any type of delimited file. A tab-delimited text file can be read in using `"\t"` as the deliminator character. In this class you **ALWAYS** want to include `header=TRUE` to signify that the data in the first row contains our column names. 
```{r}
email <- read.table("../data/email.txt", header=TRUE, sep="\t")
str(email)
```

### CSV: Comma Separated Values
CSV is a fancy way of saying a text file with comma-separated values (i.e. CSV). We could use `read.table()` but `read.csv()` is optimized to read in CSV files. 

```{r}
NCbirths <- read.csv("../data/NCbirths.csv", header=TRUE)
str(NCbirths)
```


### Excel files
The best method I have found so far to read in Excel files is from the [`readxl` package](http://readxl.tidyverse.org/) by [Hadley Wickham](http://hadley.nz/). This package need to be installed first, and then can be simply loaded each time you start an `R` session where you will be reading in this type of data. Go ahead and install it now.  

The `read_excel()` function is what we are going to use. Note the use of the underscore `_` instead of a period `.` between read and the file type.  

```{r, eval=-6}
library(readxl)
parHIV  <- read_excel("../data/PARHIV_090516.xlsx", sheet=1, col_names=TRUE)
# str(parHIV) #Not run due to the length of output. 
parHIV[1:10,1:10]
```

Due to the large number of variables (123) in this parental HIV data set, `str` is not used to demonstrate what the data looks like, instead the first 10 rows and first 10 columns are displayed. 

#### **INTERLUDE:** What are those `NA`'s? 

R puts a `NA` as a placeholder when the value for that piece of data is missing. This is important because `R` can't do arithmetic on missing data. So `5 + NA = NA`. This can cause confusion when trying to calculate summary statistics and plot data. 

Resources for learning about how R handles missing data

* http://www.statmethods.net/input/missingdata.html
* http://www.ats.ucla.edu/stat/r/faq/missing.htm
* http://faculty.nps.edu/sebuttre/home/R/missings.html

One of the best statistical methods for dealing with Missing data is called Multiple Imputation. Here is a link to learn more about this method.
https://www.r-bloggers.com/imputing-missing-data-with-r-mice-package/
**Caution: Do not use without consultation of a trained Statistician.**



# Factors
The term factor refers to a statistical data type used to store categorical variables. The difference between a categorical variable and a continuous variable is that a categorical variable corresponds to a limited number of categories, while a continuous variable can correspond to an infinite number of values. 

An example of a categorical variable is the `number` variable in the `email` data set. This variable contains data on whether there was no number, a small number (under 1 million), or a big number in the content of the email. 

```{r}
table(email$number)
class(email$number)
```

We can see that `R` recognizes this variable as a factor variable, and that it has the three levels: `big`, `none`, and `small`. 

```{r}
levels(email$number)
```

#### Ordering of Factors
Take a moment to examine the previous table. Specifically the ordering from left to right of the factors. Seem odd? This is ordinal data, in that `none` is inherently "smaller" than `small`, which is smaller than `big`. But the ordering goes `big` - `none` - `small`, which is in Alphabetical order!

Gee thanks R. Exactly how I want my factors ordered (NOT!)

We need to take control of these factors! We can do that by specifying the `levels` of the factor. Let's create a new factor variable called `numsize` that contains the data from `number`, but in the factor ordering that we want. 

```{r}
email$numsize <- factor(email$number, levels = c("none", "small", "big"))
table(email$numsize)
```

There we go. Now it's in a readable, left to right in increasing size order. 


#### Naming of Factors
Let's consider another factor variable on the email data set, `spam`.
```{r}
table(email$spam)
class(email$spam)
```

Note it is simply displayed as a 0 or 1, and `R` is treating this variable as a numeric integer variable. Well, by reading the codebook we know that in the data this variable is a _binary indicator_ variable to identify whether or not the email is flagged as spam or not. The data has been _coded_ such that 0 = "Not Spam" and 1 = "Spam". So let's change the *labels* of the `spam` variable to reflect this knowledge. 

```{r}
email$spam_labeled <- factor(email$spam, labels =c("Not Spam", "Spam"))
table(email$spam, email$spam_labeled)
```

It is good habit to not overwrite the same variable, but to create a new one entirely when you are relabeling or reordering factor variables. That way you can confirm that the values you changed were changed correctly. We will discuss this `table()` function a little later. 


# Functions and their arguments

By now you've seen the term `function` being thrown around all over the place. Functions take inputs, called **arguments** and provide outputs, or results. A few functions you have already used are `head()`, `table()` and `subset()`. Let's look at the `mean` function again by typing ?mean. 

The **Usage** section of the documentation includes two versions of the mean() function; What's the difference? The first function 
```{r, eval=FALSE}
mean(x,...)
```

is the most general definition of the mean function. This section also shows you what the default values for each argument are. This is a very important piece to pay attention. Sometimes the default behaviors are not what you want to happen. 
```{r, eval=FALSE}
mean(x, trim = 0, na.rm = FALSE, ...)
```
In the **Arguments** section the help file defines what each argument does.

* `x` is the object that you want to take the mean of
* `trim` is a number from 0 to 0.5 that defines the fraction of observations 
  to be excluded from each side before the mean is calculated. 
* `na.rm` is a logical value (`TRUE`/`FALSE`) that tells `R` whether NA values 
  should be stripped before the computation proceeds.
* `...` is called the ellipsis, and it is a way for R to pass arguments to or 
  from other methods without the function having to name them explicitly. 

## Argument ordering
A function's arguments can be named, or can be referred to by position. As an example, let's look at a vector of random numbers where some of the data is missing. 
```{r}
y <- sample(1:100, 20)
y[sample(1:length(y),5)] <- NA
y
```

Now, let's calculate the mean.
```{r}
mean(y)
```

Oops, forgot about the missing values. We need to tell R to _remove_ the `NA`'s from the data prior to calculating the mean. 
```{r}
mean(y, na.rm=TRUE)
```

It worked fine because I named the argument to remove missing values. What if I didn't state what that argument was? 
```{r, error=TRUE}
mean(y, TRUE)
```

R is expecting a value for trim as the second argument and doesn't know what to do with the value `TRUE`. If you name the arguments, then the order is irrelevant. 

```{r}
mean(na.rm=TRUE, x=y, trim=.1)
```

But let's not get that crazy. 

We'll be getting into heavy function use, specifically with the `ggplot` function in the next lab. 

# Additional References

There are several other Data Camp courses that all have the first chapter free that you can use to get a start on learning more about how to import and clean up data. Here are a few. 

* [Cleaning Data in R](https://www.datacamp.com/courses/cleaning-data-in-r)
* [Importing Data into R](https://www.datacamp.com/courses/importing-data-into-r)
* Tidy Data - The [Journal](http://vita.had.co.nz/papers/tidy-data.pdf), and the 
  [tutorial](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html)

  
