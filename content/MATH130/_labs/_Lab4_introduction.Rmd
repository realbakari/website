---
title: 'Lab 4: Data cleaning with dplyr'
---

# Introduction 
When working with data you must:

1. Figure out what you want to do.
2. Precisely describe what you want in the form of a computer program.
3. Execute the code.

The dplyr package makes each of these steps as fast and easy as possible by:

1. Elucidating the most common data manipulation operations, so that your
   options are helpfully constrained when thinking about how to tackle a problem.
2. Providing simple functions that correspond to the most common data 
   manipulation verbs, so that you can easily translate your thoughts into code.
3. Using efficient data storage backends, so that you spend as little time 
   waiting for the computer as possible.

The goal of this lesson is to introduce you to the basic tools that dplyr provides, and show how you to apply them to data frames. You must have the `dplyr`,  `nycflights13` and `hflights` packages installed before you can proceed.  Install them now if you have not done so yet. 

Let's load all the packages we will need for this lab. Add the _code chunk_ arguments: `warning=FALSE` & `message=FALSE` to suppress pesky warnings and messages. 

```{r,  echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr); library(nycflights13)
```

## Exploring airline flight data with dplyr. 

The `nycflights13` package contains several data sets that can be used to help understand what causes delays. 

* `flights`: information about all flights that departed from NYC (e.g. EWR, JFK and LGA) in 2013. 
* `weather`: hourly meterological data for each airport
* `planes`: construction information about each plane
* `airports`: airport names and locations
* `airlines`: translation between two letter carrier codes and names

**Special notice** These data sets, and any data set created with `dplyr`
has a specific data type called a `tibble`. These are not as furry and prolific as their cousins the `tribbles`. `tibbles` behaves for all intents and purposes as a `data.frame`, just gets displayed differently. For example, the `flights` data set contains data on 19 characteristics (variables) from 336,776 flights. There's no way I would want to print out a data set that large. But i'm gonna....  

```{r}
flights
```

The output has been trimmed to something more reasonable for our viewing pleasure. 

# The 5 basic verbs
The `dplyr` package contains five key data manipulation functions, also called verbs:

* `filter()`: Returns a subset of the rows.
* `arrange()`: Reorders the rows according to single or multiple variables.
* `select()`: Returns a subset of the columns.
* `mutate()`: Adds columns from existing data.
* `summarise()`: Reduces each group to a single row by calculating aggregate measures.

You will learn how to use these verbs in the first part of this lab, then will have a chance to practice on new data. 

## Filter
`filter()` allows you to select a subset of the rows of a data frame. 
The first argument is the name of the data frame, and the second and subsequent are filtering expressions evaluated in the context of that data frame. For example, we can select all flights on January 1st with 
```{r}
filter(flights, month == 1, day == 1)
```


`filter()` works similarly to `subset()` except that you can give it any number of filtering conditions which are joined together with &. You can use other Boolean operators explicitly. Fill in the blanks to filter the flights data set to only select flights in January or February.
```{r}
filter(flights, month == 1 | month == 2)
```


## Slice
To select rows by position, use `slice()`. You can slice off the top 5 rows by typing
```{r}
slice(flights, 1:5)
```
Don't forget the first argument is the data frame. 

## Arrange
`arrange()` works similarly to `filter()` except that instead of filtering or selecting rows, it reorders them. It takes a data frame, and a set of column names (or more complicated expressions) to order by. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns. Here we arrange the flights data in chronological order by typing 
```{r}
arrange(flights, year, month, day)
```

We can sort a variable in descending order (largest to smallest) by using `desc()` on the variable of interest. Fill in the blank to sort flights by descending arrival delay.
```{r}
arrange(flights, desc(arr_delay)) 
```

## Select
Often you work with large datasets with many columns where only a few are actually of interest to you. `select()` allows you to rapidly zoom in on a useful subset using operations that usually only work on numeric variable positions.
```{r}
select(flights, month, day, year)
```

Type `select(flights, year:day)` to select all columns physically located between year and day.
```{r}
select(flights, sched_dep_time:carrier)
```

Type `select(flights, -(year:day))` to select all columns EXCEPT the ones between year and day.
```{r, eval=FALSE}
select(flights, -carrier)
```

## Mutate
As well as selecting from the set of existing columns, it's often useful to add new columns that are functions of existing columns. This is the job of mutate()!

Here we create two variables: gain (as arrival delay minus departure delay) and speed (as distance divided by time, converted to hours). 
```{r}
a <- mutate(flights, gain = arr_delay - dep_delay, 
                speed = distance / air_time * 60)
select(a, gain, distance, air_time, speed)
```


One key advantage of mutate is that you can refer to the columns you just created. Mutate flights to create two variables, `gain = arr_delay - dep_delay` and `gain_per_hour = gain / (air_time / 60)`. 
```{r}
mutate(flights, gain = arr_delay - dep_delay, 
                gain_per_hour = gain / (air_time / 60 ))
```  


## Summarize
The last verb is `summarise()`, which collapses a data frame to a single row. It's not very useful yet. We can create a new variable called delay that is the average departure delay on the entire flights data set. 
```{r}
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
```

## Practice
Go do Lab 4 - Practice with the basic 5 commands


# Grouped Operations
The above verbs are useful, but they become really powerful when you combine them with the idea of "group by", repeating the operation individually on groups of observations within the dataset. In dplyr, you use the `group_by()` function to describe how to break a dataset down into groups of rows. You can then use the resulting object in exactly the same functions as above; they'll automatically work "by group" when the input is a grouped.

Let's demonstrate how some of these functions work after grouping the flights data set by month. First we'll create a new data set that is grouped by month. 

```{r}
by_month <- group_by(flights, month)
```

* If we want to sort the data, `arrange()` orders first by grouping variables, 
  then by the sorting variable. 
```{r}
how_long <- arrange(by_month, distance)
select(how_long, month, distance)
```

* Now that the data is sorted by shortest to longest distance, we can use 
  `slice()` extract the shortest flight per month. 
```{r}
slice(how_long, 1)
```

* The `summarise()` verb allows you to calculate summary statistics for each 
  group. This is probably the most common function that is used in conjunction 
  with `group_by`. For example, the average distance flown per month. 
```{r}
summarise(by_month, avg_airtime = mean(distance, na.rm=TRUE))
```
Or simply the total number of flights per month. 
```{r}
summarize(by_month, count=n())
```


# Chaining Operations
Consider the following group of operations that take the data set `flights`, and produce a final data set (`a4`) that contains only the flights where the daily average delay is greater than a half hour. 
```{r}
a1 <- group_by(flights, year, month, day)
a2 <- select(a1, arr_delay, dep_delay)
a3 <- summarise(a2,
                arr = mean(arr_delay, na.rm = TRUE),
                dep = mean(dep_delay, na.rm = TRUE))
a4 <- filter(a3, arr > 30 | dep > 30)
head(a4)
```

It does the trick, but what if you don't want to save all the intermediate results (`a1` - `a3`)? Well these verbs are `function`, so they can be wrapped inside other functions to create a nesting type structure.  
```{r, eval=FALSE}
filter(
  summarise(
    select(
      group_by(flights, year, month, day),
      arr_delay, dep_delay
    ),
    arr = mean(arr_delay, na.rm = TRUE),
    dep = mean(dep_delay, na.rm = TRUE)
  ),
  arr > 30 | dep > 30
)
```

Woah, that is HARD to read! This is difficult to read because the order of the operations is from inside to out, and the arguments are a long way away from the function. To get around this problem, dplyr provides the `%>%` operator. `x %>% f(y)` turns into `f(x, y)` so you can use it to rewrite multiple operations so you can read from left-to-right, top-to-bottom:

```{r}
flights %>%
  group_by(year, month, day) %>%
  select(arr_delay, dep_delay) %>%
  summarise(
    arr = mean(arr_delay, na.rm = TRUE),
    dep = mean(dep_delay, na.rm = TRUE)
  ) %>%
  filter(arr > 30 | dep > 30)
```

Another way you can read this is by thinking "and then" when you see the `%>%` 
operator. So the above code takes the data set flights  
.. and then groups by day  
.. and then selects the delay variables  
.. and then calculates the means  
.. and then filters on a delay over half hour. 

The same 4 steps that resulted in the `a4` data set, but without all the intermediate data saved! This can be **very important** when dealing with Big Data. `R` stores all data in memory, so if your little computer only has 2G of RAM and you're working with a data set that is 500M in size, your computers memory will be used up fast. `a1` takes 500M, `a2` another 500M, by now your computer is getting slow. Make another copy at `a3` and it gets worse, `a4` now likely won't even be able to be created because you'll be out of memory. 


## Practice
Go do Lab 4 - Practice on Chaining Operations. 


# Joining data from multiple tables
Alright, so we can finangle and mess around with one table pretty easily. Great. But oh so often you want to combine a piece of information in one data set, say demographic characteristics on a person with information contained in a second data set, such as grades or salary. In comes table joins. 

Important note - SQL is the powerhouse language of database management. `dplyr` can be used in a similar manner, but obviously only works in R whereas SQL is nearly universal and can be written by itself, and in a number of other statistics and data analysis software packages. 


This part of the tutorial comes directly from a combination of Jenny Bryan at Unversity of British Columbia's STAT 545 course.  http://stat545.com/bit001_dplyr-cheatsheet.html (She has a sheer magnitude of amazing stuff), with a modification of how the data is created by Nate Byers(https://rpubs.com/NateByers/Merging). 

Let's create some data to play with

```{r}
superheroes <- read.table(header=TRUE, text='
    name alignment gender         publisher
 Magneto       bad   male            Marvel
   Storm      good female            Marvel
Mystique       bad female            Marvel
  Batman      good   male                DC
   Joker       bad   male                DC
Catwoman       bad female                DC
 Hellboy      good   male         DarkHorse
')

publishers <- read.table(header=TRUE, text='
  publisher yr_founded
         DC       1934
     Marvel       1939
      Image       1992
')
```

## What's a table join? 

In dplyr, there are three families of verbs that work with two tables at a time:

* Mutating joins, which add new variables to one table from matching rows in another.
* Filtering joins, which filter observations from one table based on whether or not they match an observation in the other table.
* Set operations, which combine the observations in the data sets as if they were set elements.

We are only going to cover some of the more simple mutating and filtering joins. 


### Inner Join
> inner_join(x, y): Return all rows from x where there are matching values in y, and all columns from x and y. 
> If there are multiple matches between x and y, all combination of the matches are returned. 

```{r}
inner_join(superheroes, publishers)
```

We lose Hellboy in the join because, although he appears in `superheroes`, his publisher Dark Horse Comics does not appear in `publishers`. The join result has all variables from both data sets. 

**Does order matter? **
```{r}
inner_join(publishers, superheroes)
```

#### controlling the key match
Somewhat trivial here, but not always. What variable do you want to match on? 

```{r}
inner_join(superheroes, publishers, by="publisher")
```


### Left Join 

> left_join(x, y): Return all rows from x, and all columns from x and y. 
> If there are multiple matches between x and y, all combination of the matches are returned. 

One of the most common types of joins. Pull info from table y, and add it to table x on some key variable. 

```{r}
left_join(superheroes, publishers)
```

We basically get `superheroes` back, but with the addition of variable `yr_founded` Hellboy, whose publisher does not appear in `publishers`, is missing this variable.  

**Does order matter? **
```{r}
left_join(publishers, superheroes)
```

Yes! Here we're adding superhero information to the publisher information. Each row in the publisher data set is repeated for each superhero that matches that publisher. 


### Full Join

> full_join(x, y): Return all rows and all columns from both x and y. 

```{r}
full_join(superheroes, publishers)
```

We get all rows of `superheroes` plus a new row from `publishers`, containing the publisher Image. We get all variables from both data sets, varibles without matches in the other data set simply get an NA. 


## Practice
Go do Lab 4 - Practice on table joins


# Additional Resources
The ability to manipulate, arrange and clean up data is an extremely important skill to have. It is advised that you review at least one other tutorial method for using dplyr if you are still uncomfortable with it. Remember, it is all about practice. The more you use it the easier it will become!

* R Studio's [Data Wrangling Cheat Sheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)
* [Data Camp](https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial) has a dplyr lesson
* [Dplyr vignette](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)
* [Table joining vignette](https://cran.r-project.org/web/packages/dplyr/vignettes/two-table.html) 
* [Hands-on dplyr tutorial for faster data manipulation in R](https://www.youtube.com/watch?v=jWjqLW-u3hc) You Tube video by Data School
* UBC STAT 545 (this class is awesome!) http://stat545.com
* Merging in R by Nate Byers on RPubs https://rpubs.com/NateByers/Merging

